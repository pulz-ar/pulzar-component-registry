{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "pulzar/orb",
  "type": "registry:block",
  "title": "Pulzar Orb",
  "description": "Orb animado (canvas) con soporte opcional de shaders (MeshGradient).",
  "dependencies": [
    "@paper-design/shaders-react"
  ],
  "files": [
    {
      "path": "registry/new-york/blocks/pulzar/orb.tsx",
      "content": "\"use client\"\n\nimport React, { useEffect, useMemo, useRef } from \"react\"\nimport { MeshGradient, LiquidMetal } from \"@paper-design/shaders-react\"\n\ntype Theme = \"dark\" | \"light\"\n\ninterface SquareOptions {\n  size?: number\n  rotation?: number\n  color?: string\n  borderColor?: string\n  borderWidth?: number\n  rotationOffset?: number\n}\n\ninterface FigureOptions {\n  squares?: Square[]\n}\n\ninterface Animation {\n  name: string\n  duration: number\n  elapsedTime: number\n  finished: boolean\n  update: (deltaTime: number, elapsedTime: number) => void\n  onComplete?: () => void\n}\n\nclass Figure {\n  public squares: Square[]\n  public offsetX: number\n  public offsetY: number\n\n  constructor(options: FigureOptions = {}) {\n    this.squares = options.squares || []\n    this.offsetX = 0\n    this.offsetY = 0\n  }\n\n  public draw(ctx: CanvasRenderingContext2D, canvasWidth: number, canvasHeight: number): void {\n    ctx.save()\n    ctx.translate(canvasWidth / 2 + this.offsetX, canvasHeight / 2 + this.offsetY)\n    this.squares.forEach((square: Square) => square.draw(ctx))\n    ctx.restore()\n  }\n}\n\nclass Square {\n  public size: number\n  public rotation: number\n  public color: string\n  public borderColor: string\n  public borderWidth: number\n  public scale: number\n  public rotationOffset: number\n  public accumulatedRotation: number\n  public isRotated: boolean\n  public initialRotation: number\n  public initialScale: number\n  public motionBlur: number\n  public originalBorderColor: string\n  public originalColor: string\n\n  constructor(options: SquareOptions = {}) {\n    this.size = options.size || 100\n    this.rotation = options.rotation || 0\n    this.color = options.color || \"rgba(0, 0, 0, 0)\"\n    this.borderColor = options.borderColor || \"#000000\"\n    this.borderWidth = options.borderWidth || 4\n    this.scale = 1\n    this.rotationOffset = options.rotationOffset || 0\n    this.accumulatedRotation = 0\n    this.isRotated = false\n    this.initialRotation = this.rotation\n    this.initialScale = this.scale\n    this.motionBlur = 0\n    this.originalBorderColor = this.borderColor\n    this.originalColor = this.color\n  }\n\n  public draw(ctx: CanvasRenderingContext2D): void {\n    ctx.save()\n    ctx.rotate(((this.rotation + this.rotationOffset) * Math.PI) / 180)\n    ctx.scale(this.scale, this.scale)\n\n    if (this.motionBlur > 0) {\n      const steps = 5\n      const alpha = 0.3 / steps\n\n      for (let i = 0; i < steps; i++) {\n        ctx.save()\n        ctx.rotate(((-this.motionBlur * 5 * i) * Math.PI) / 180)\n        ctx.globalAlpha = alpha * (steps - i)\n\n        ctx.fillStyle = this.color\n        ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size)\n\n        if (this.borderColor && this.borderWidth) {\n          ctx.lineWidth = this.borderWidth\n          ctx.strokeStyle = this.borderColor\n          ctx.strokeRect(-this.size / 2, -this.size / 2, this.size, this.size)\n        }\n\n        ctx.restore()\n      }\n    } else {\n      ctx.fillStyle = this.color\n      ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size)\n\n      if (this.borderColor && this.borderWidth) {\n        ctx.lineWidth = this.borderWidth\n        ctx.strokeStyle = this.borderColor\n        ctx.strokeRect(-this.size / 2, -this.size / 2, this.size, this.size)\n      }\n    }\n\n    ctx.restore()\n  }\n}\n\nclass OrbEngine {\n  public figure: Figure\n  public canvas: HTMLCanvasElement\n  public ctx: CanvasRenderingContext2D\n  public lastTime: number | null\n  public squareAnimations: (Animation | null)[]\n  public idleAnimations: Animation[]\n  public animationQueues: Animation[][]\n  public pendingAnimations: (() => void)[]\n  private isLoading: boolean\n  private isRandomAnimating: boolean\n  private shaderMode: \"none\" | \"figure\"\n  private getShaderCanvas?: () => HTMLCanvasElement | null\n  private maskCanvas?: HTMLCanvasElement\n\n  constructor(figure: Figure, canvasElement: HTMLCanvasElement) {\n    this.figure = figure\n    this.canvas = canvasElement\n    const context = this.canvas.getContext(\"2d\")\n    if (!context) {\n      throw new Error(\"CanvasRenderingContext2D not available\")\n    }\n    this.ctx = context\n    this.lastTime = null\n    this.squareAnimations = this.figure.squares.map(() => null)\n    this.idleAnimations = []\n    this.animationQueues = this.figure.squares.map(() => [])\n    this.pendingAnimations = []\n    this.isLoading = false\n    this.isRandomAnimating = false\n    this.shaderMode = \"none\"\n\n    this.animate = this.animate.bind(this)\n\n    this.canvas.addEventListener(\"click\", () => {\n      if (!this.isAnimating()) {\n        this.explode()\n      } else {\n        this.queueAnimation(() => this.explode())\n      }\n    })\n\n    window.addEventListener(\"keydown\", (e) => {\n      if (e.key === \"Enter\") {\n        this.spin()\n      }\n    })\n\n    this.setupIdleAnimations()\n    requestAnimationFrame(this.animate)\n  }\n\n  public setShader(getter: (() => HTMLCanvasElement | null) | undefined, mode: \"none\" | \"figure\"): void {\n    this.getShaderCanvas = getter\n    this.shaderMode = mode\n  }\n\n  public loading(shouldLoad: boolean = true): void {\n    this.isLoading = shouldLoad\n  }\n\n  public setupIdleAnimations(): void {\n    this.idleAnimations = this.figure.squares.map((square: Square, index: number) => {\n      const idleAnimation: Animation = {\n        name: \"idle\",\n        duration: Infinity,\n        elapsedTime: 0,\n        finished: false,\n        update: (_deltaTime: number, elapsedTime: number) => {\n          const pulseAmplitude = 0.05 + index * 0.01\n          const scaleSpeed = 0.001 + index * 0.0005\n          const t = elapsedTime * scaleSpeed\n          square.scale = square.initialScale + Math.sin(t) * pulseAmplitude\n        },\n      }\n      return idleAnimation\n    })\n  }\n\n  public reset(): void {\n    this.isRandomAnimating = false\n    const squaresToReset = this.figure.squares\n      .map((square: Square, index: number) => (square.isRotated ? index : null))\n      .filter((index: number | null) => index !== null)\n\n    if ((squaresToReset as number[]).length > 0) {\n      this.playRotationAnimation(squaresToReset as number[], 45, 1000)\n    }\n\n    this.figure.squares.forEach((_square: Square, index: number) => {\n      this.squareAnimations[index] = this.squareAnimations[index] || null\n      this.idleAnimations[index].elapsedTime = 0\n      this.idleAnimations[index].finished = false\n    })\n  }\n\n  public playRotationAnimation(squareIndices: number[], angle: number, duration: number): void {\n    squareIndices.forEach((index: number) => {\n      const square = this.figure.squares[index]\n      const startRotation = square.rotation\n\n      const animation: Animation = {\n        name: \"rotate\",\n        duration: duration || 1000,\n        elapsedTime: 0,\n        finished: false,\n        update: (_deltaTime: number, elapsedTime: number) => {\n          const progress = elapsedTime / animation.duration\n          const easedProgress = progress < 0.5\n            ? 4 * progress * progress * progress\n            : 1 - Math.pow(-2 * progress + 2, 3) / 2\n\n          if (angle === 360) {\n            const velocity = Math.sin(progress * Math.PI)\n            square.motionBlur = velocity * 0.3\n          }\n\n          const newRotation = startRotation + easedProgress * angle\n          square.rotation = newRotation\n        },\n        onComplete: () => {\n          square.rotation = startRotation + angle\n          square.accumulatedRotation = (square.accumulatedRotation + angle) % 360\n          if (angle === 45) {\n            square.isRotated = !square.isRotated\n          }\n          square.motionBlur = 0\n\n          if (this.animationQueues[index].length > 0) {\n            this.squareAnimations[index] = this.animationQueues[index].shift()!\n          } else {\n            this.squareAnimations[index] = null\n          }\n        },\n      }\n\n      if (this.squareAnimations[index]) {\n        this.animationQueues[index].push(animation)\n      } else {\n        this.squareAnimations[index] = animation\n      }\n    })\n  }\n\n  public playScaleAnimation(squareIndices: number[], scaleFactor: number, duration: number): void {\n    squareIndices.forEach((index: number) => {\n      const square = this.figure.squares[index]\n      this.squareAnimations[index] = null\n\n      const startScale = square.scale\n      const targetScale = square.initialScale * scaleFactor\n\n      const animation: Animation = {\n        name: \"scale\",\n        duration: duration || 1000,\n        elapsedTime: 0,\n        finished: false,\n        update: (_deltaTime: number, elapsedTime: number) => {\n          const progress = elapsedTime / animation.duration\n          const easedProgress = progress < 0.5\n            ? 4 * progress * progress * progress\n            : 1 - Math.pow(-2 * progress + 2, 3) / 2\n          if (progress < 0.5) {\n            const scale = startScale + easedProgress * (targetScale - startScale)\n            square.scale = scale\n          } else {\n            const scale = targetScale - (easedProgress - 0.5) * 2 * (targetScale - startScale)\n            square.scale = scale\n          }\n        },\n        onComplete: () => {\n          square.scale = square.initialScale\n          this.squareAnimations[index] = null\n\n          if (this.animationQueues[index].length > 0) {\n            const nextAnimation = this.animationQueues[index].shift()!\n            this.squareAnimations[index] = nextAnimation\n          }\n        },\n      }\n\n      if (this.squareAnimations[index]) {\n        this.animationQueues[index].push(animation)\n      } else {\n        this.squareAnimations[index] = animation\n      }\n    })\n  }\n\n  public playScaleAnimationWithDelay(squareIndex: number, scaleFactor: number, duration: number, delay: number): void {\n    const square = this.figure.squares[squareIndex]\n    const startScale = square.scale\n    const targetScale = square.initialScale * scaleFactor\n\n    const animation: Animation = {\n      name: \"scale\",\n      duration: duration,\n      elapsedTime: -delay,\n      finished: false,\n      update: (_deltaTime: number, elapsedTime: number) => {\n        if (elapsedTime < 0) {\n          return\n        }\n\n        const progress = elapsedTime / animation.duration\n\n        if (progress < 0.5) {\n          const upProgress = progress * 2\n          const easeUp = 1 - Math.cos((upProgress * Math.PI) / 2)\n          square.scale = startScale + easeUp * (targetScale - startScale)\n        } else {\n          const downProgress = (progress - 0.5) * 2\n          const easeDown = Math.cos((downProgress * Math.PI) / 2)\n          square.scale = square.initialScale + easeDown * (targetScale - square.initialScale)\n        }\n      },\n      onComplete: () => {\n        square.scale = square.initialScale\n\n        if (this.animationQueues[squareIndex].length > 0) {\n          this.squareAnimations[squareIndex] = this.animationQueues[squareIndex].shift()!\n        } else {\n          this.squareAnimations[squareIndex] = null\n        }\n      },\n    }\n\n    if (this.squareAnimations[squareIndex]) {\n      this.animationQueues[squareIndex].push(animation)\n    } else {\n      this.squareAnimations[squareIndex] = animation\n    }\n  }\n\n  public animate(timestamp: number): void {\n    if (!this.lastTime) {\n      this.lastTime = timestamp\n    }\n    const deltaTime = timestamp - this.lastTime\n    this.lastTime = timestamp\n\n    this.update(deltaTime)\n    this.draw()\n\n    requestAnimationFrame(this.animate)\n  }\n\n  public update(deltaTime: number): void {\n    let allAnimationsFinished = true\n\n    this.squareAnimations.forEach((animation: Animation | null, index: number) => {\n      if (animation && !animation.finished) {\n        allAnimationsFinished = false\n        animation.elapsedTime += deltaTime\n\n        if (animation.elapsedTime >= animation.duration) {\n          animation.update(deltaTime, animation.duration)\n          if (animation.onComplete) {\n            animation.onComplete()\n          }\n          animation.finished = true\n\n          if (this.animationQueues[index].length > 0) {\n            this.squareAnimations[index] = this.animationQueues[index].shift()!\n            allAnimationsFinished = false\n          }\n        } else {\n          animation.update(deltaTime, animation.elapsedTime)\n        }\n      }\n    })\n\n    if (allAnimationsFinished && this.pendingAnimations && this.pendingAnimations.length > 0) {\n      const nextAnimation = this.pendingAnimations.shift()\n      if (nextAnimation) {\n        nextAnimation()\n      }\n    }\n\n    if (allAnimationsFinished) {\n      this.idleAnimations.forEach((idleAnimation: Animation) => {\n        if (idleAnimation && !idleAnimation.finished) {\n          idleAnimation.elapsedTime += deltaTime\n          idleAnimation.update(deltaTime, idleAnimation.elapsedTime)\n        }\n      })\n    }\n  }\n\n  public draw(): void {\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n    if (this.shaderMode === \"figure\") {\n      const shaderCanvas = this.getShaderCanvas ? this.getShaderCanvas() : null\n      if (shaderCanvas && shaderCanvas.width > 0 && shaderCanvas.height > 0) {\n        this.drawShaderMaskedToOrb(shaderCanvas)\n        return\n      }\n    }\n    this.ctx.save()\n    this.figure.draw(this.ctx, this.canvas.width, this.canvas.height)\n    this.ctx.restore()\n  }\n\n  private drawShaderMaskedToOrb(shaderCanvas: HTMLCanvasElement): void {\n    const ctx = this.ctx\n\n    // 0) Preparar canvas de máscara (union de las superficies del orbe)\n    if (!this.maskCanvas) {\n      this.maskCanvas = document.createElement(\"canvas\")\n    }\n    const m = this.maskCanvas\n    if (m.width !== this.canvas.width || m.height !== this.canvas.height) {\n      m.width = this.canvas.width\n      m.height = this.canvas.height\n    }\n    const mctx = m.getContext(\"2d\")!\n    mctx.clearRect(0, 0, m.width, m.height)\n    mctx.save()\n    mctx.translate(this.canvas.width / 2 + this.figure.offsetX, this.canvas.height / 2 + this.figure.offsetY)\n    mctx.fillStyle = \"#fff\"\n\n    const drawRingTo = (c: CanvasRenderingContext2D, size: number, borderWidth: number, rotationDeg: number, scale: number) => {\n      // strokeRect en el render original centra el trazo sobre el borde del rectángulo de tamaño `size`.\n      // Por lo tanto, el contorno visible final extiende +borderWidth/2 hacia afuera y -borderWidth/2 hacia adentro.\n      // Para que la máscara coincida exactamente, usamos outer = size + borderWidth y inner = size - borderWidth.\n      const outer = size + borderWidth\n      const inner = Math.max(0, size - borderWidth)\n      c.save()\n      c.rotate((rotationDeg * Math.PI) / 180)\n      c.scale(scale, scale)\n      c.beginPath()\n      c.rect(-outer / 2, -outer / 2, outer, outer)\n      c.rect(-inner / 2, -inner / 2, inner, inner)\n      c.fill(\"evenodd\")\n      c.restore()\n    }\n\n    const outer = this.figure.squares[0]\n    const middle = this.figure.squares[1]\n    const center = this.figure.squares[this.figure.squares.length - 1]\n    if (outer && outer.borderWidth > 0) {\n      drawRingTo(mctx, outer.size, outer.borderWidth, outer.rotation + outer.rotationOffset, outer.scale)\n    }\n    if (middle && middle.borderWidth > 0) {\n      drawRingTo(mctx, middle.size, middle.borderWidth, middle.rotation + middle.rotationOffset, middle.scale)\n    }\n    if (center) {\n      mctx.save()\n      mctx.rotate(((center.rotation + center.rotationOffset) * Math.PI) / 180)\n      mctx.scale(center.scale, center.scale)\n      // Centro en el original es fill + stroke. Para coincidir el contorno total, expandimos por +borderWidth/2 en cada lado.\n      const centerOuter = center.size + (center.borderWidth || 0)\n      mctx.fillRect(-centerOuter / 2, -centerOuter / 2, centerOuter, centerOuter)\n      mctx.restore()\n    }\n    mctx.restore()\n\n    // 1) Pintar shader en destino\n    ctx.save()\n    ctx.drawImage(shaderCanvas, 0, 0, this.canvas.width, this.canvas.height)\n    // 2) Aplicar máscara en una sola operación (union)\n    ctx.globalCompositeOperation = \"destination-in\"\n    ctx.drawImage(m, 0, 0)\n    ctx.restore()\n    ctx.globalCompositeOperation = \"source-over\"\n  }\n\n  public rotate45(): void {\n    const squareIndices = [0, 1, 2]\n    this.playRotationAnimation(squareIndices, 45, 1000)\n  }\n\n  public rotate45Center(): void {\n    this.playRotationAnimation([2], 45, 1000)\n  }\n\n  public rotate45External(withChilds: boolean = false): void {\n    if (withChilds) {\n      this.playRotationAnimation([0, 1, 2], 45, 1000)\n    } else {\n      this.playRotationAnimation([0], 45, 1000)\n    }\n  }\n\n  public rotate45Middle(withChilds: boolean = false): void {\n    if (withChilds) {\n      this.playRotationAnimation([1, 2], 45, 1000)\n    } else {\n      this.playRotationAnimation([1], 45, 1000)\n    }\n  }\n\n  public explode(onComplete?: () => void): void {\n    const animations = [\n      { index: 0, scale: 1.2, duration: 1200, delay: 0 },\n      { index: 1, scale: 1.3, duration: 900, delay: 100 },\n      { index: 2, scale: 1.5, duration: 600, delay: 200 },\n    ]\n\n    animations.forEach(({ index, scale, duration, delay }) => {\n      if (index === animations.length - 1 && onComplete) {\n        const originalAnimation = this.squareAnimations[index]\n        if (originalAnimation && \"onComplete\" in originalAnimation) {\n          const originalOnComplete = originalAnimation.onComplete\n          originalAnimation.onComplete = () => {\n            if (originalOnComplete) {\n              originalOnComplete()\n            }\n            onComplete()\n          }\n        }\n      }\n      this.playScaleAnimationWithDelay(index, scale, duration, delay)\n    })\n  }\n\n  public spin(): void {\n    this.playRotationAnimation([0], 180, 2000)\n    this.playRotationAnimation([1], 360, 2000)\n    this.playRotationAnimation([2], 720, 2000)\n  }\n\n  public isAnimatingSquare(squareIndex: number): boolean {\n    const hasActive = this.squareAnimations[squareIndex] !== null\n    const hasQueue = this.animationQueues[squareIndex].length > 0\n    return hasActive || hasQueue\n  }\n\n  public queueAnimation(animationCallback: () => void): void {\n    this.pendingAnimations = this.pendingAnimations || []\n    this.pendingAnimations.push(animationCallback)\n  }\n\n  public isAnimating(): boolean {\n    return this.figure.squares.some((_, index) => this.isAnimatingSquare(index))\n  }\n\n  private hexToRgb(hex: string): { r: number; g: number; b: number } | null {\n    const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex)\n    if (!result) {\n      return null\n    }\n    return {\n      r: parseInt(result[1], 16),\n      g: parseInt(result[2], 16),\n      b: parseInt(result[3], 16),\n    }\n  }\n\n  public alert(fromColor: string, toColor?: string, initialDuration?: number, repetitions?: number): void {\n    const targetColor = toColor || fromColor\n    const baseDuration = initialDuration || 2000\n    const loops = repetitions === undefined ? 1 : repetitions\n\n    ;[0, 1, 2].forEach((index) => {\n      const square = this.figure.squares[index]\n      const startScale = square.scale\n      const maxScale = square.initialScale * (1.1 + index * 0.05)\n\n      const fromRGB = this.hexToRgb(fromColor)\n      const toRGB = this.hexToRgb(targetColor)\n      if (!fromRGB || !toRGB) {\n        return\n      }\n\n      const progressBase = index / 2\n      const targetRGB = {\n        r: Math.round(fromRGB.r + (toRGB.r - fromRGB.r) * progressBase),\n        g: Math.round(fromRGB.g + (toRGB.g - fromRGB.g) * progressBase),\n        b: Math.round(fromRGB.b + (toRGB.b - fromRGB.b) * progressBase),\n      }\n\n      const totalDuration = Array.from({ length: loops }, (_: unknown, i: number) => Math.max(500, baseDuration - i * 300)).reduce((a: number, b: number) => a + b, 0)\n\n      const animation: Animation = {\n        name: \"alert\",\n        duration: totalDuration,\n        elapsedTime: -index * (baseDuration * 0.1),\n        finished: false,\n        update: (_deltaTime: number, elapsedTime: number) => {\n          if (elapsedTime < 0) {\n            return\n          }\n\n          let currentRepetition = 0\n          let timeInCurrentRepetition = elapsedTime\n\n          for (let i = 0; i < loops; i++) {\n            const currentDuration = Math.max(500, baseDuration - i * 300)\n            if (timeInCurrentRepetition < currentDuration) {\n              currentRepetition = i\n              break\n            }\n            timeInCurrentRepetition -= currentDuration\n          }\n\n          if (currentRepetition >= loops) {\n            animation.finished = true\n            return\n          }\n\n          const currentDuration = Math.max(500, baseDuration - currentRepetition * 300)\n          const progress = timeInCurrentRepetition / currentDuration\n\n          if (progress <= 0.5) {\n            const upProgress = progress * 2\n            const easeUp = 1 - Math.cos((upProgress * Math.PI) / 2)\n\n            square.scale = startScale + (maxScale - startScale) * easeUp\n\n            const colorThreshold = 0.3\n            const shouldColor = upProgress >= index * colorThreshold\n\n            if (shouldColor) {\n              const individualProgress = Math.min(1, (upProgress - index * colorThreshold) / colorThreshold)\n              const easeColor = 1 - Math.cos((individualProgress * Math.PI) / 2)\n\n              const r = Math.round(255 + (targetRGB.r - 255) * easeColor)\n              const g = Math.round(255 + (targetRGB.g - 255) * easeColor)\n              const b = Math.round(255 + (targetRGB.b - 255) * easeColor)\n\n              square.borderColor = `rgb(${r}, ${g}, ${b})`\n              if (square.originalColor !== \"rgba(0, 0, 0, 0)\") {\n                square.color = `rgb(${r}, ${g}, ${b})`\n              }\n            }\n          } else {\n            const fadeProgress = (progress - 0.5) * 2\n            const fadeThreshold = 0.3\n            const shouldFade = fadeProgress >= index * fadeThreshold\n\n            if (shouldFade) {\n              const individualFadeProgress = Math.min(1, (fadeProgress - index * fadeThreshold) / fadeThreshold)\n              const easeFade = Math.cos((individualFadeProgress * Math.PI) / 2)\n\n              const r = Math.round(255 + (targetRGB.r - 255) * easeFade)\n              const g = Math.round(255 + (targetRGB.g - 255) * easeFade)\n              const b = Math.round(255 + (targetRGB.b - 255) * easeFade)\n\n              square.borderColor = `rgb(${r}, ${g}, ${b})`\n              if (square.originalColor !== \"rgba(0, 0, 0, 0)\") {\n                square.color = `rgb(${r}, ${g}, ${b})`\n              }\n\n              square.scale = square.initialScale + (maxScale - square.initialScale) * easeFade\n            }\n          }\n        },\n        onComplete: () => {\n          square.scale = square.initialScale\n          square.borderColor = square.originalBorderColor\n          square.color = square.originalColor\n\n          if (this.animationQueues[index].length > 0) {\n            this.squareAnimations[index] = this.animationQueues[index].shift()!\n          } else {\n            this.squareAnimations[index] = null\n          }\n        },\n      }\n\n      if (this.squareAnimations[index]) {\n        this.animationQueues[index].push(animation)\n      } else {\n        this.squareAnimations[index] = animation\n      }\n    })\n  }\n}\n\nexport interface OrbProps {\n  width?: number\n  height?: number\n  initialAnimation?: string\n  theme?: Theme\n  className?: string\n  ariaHidden?: boolean\n  shader?: {\n    type: \"mesh-gradient\" | \"liquid-metal\"\n    colors?: string[]\n    distortion?: number\n    swirl?: number\n    speed?: number\n    position?: \"figure\" // only figure is supported; background/foreground are ignored\n    // LiquidMetal specific (optional)\n    colorBack?: string\n    colorTint?: string\n    repetition?: number\n    softness?: number\n    shiftRed?: number\n    shiftBlue?: number\n    contour?: number\n    shape?: string\n    offsetX?: number\n    offsetY?: number\n    scale?: number\n    rotation?: number\n  }\n}\n\nexport function Orb(props: OrbProps) {\n  const canvasRef = useRef<HTMLCanvasElement | null>(null)\n  const orbRef = useRef<OrbEngine | null>(null)\n  const shaderCanvasRef = useRef<HTMLCanvasElement | null>(null)\n  const shaderHostRef = useRef<HTMLDivElement | null>(null)\n\n  const width = props.width || 360\n  const height = props.height || 360\n  const theme: Theme = props.theme || \"dark\"\n  const initialAnimation = props.initialAnimation\n\n  const baseColor = useMemo(() => {\n    if (theme === \"dark\") {\n      return \"rgba(255, 255, 255, 0.9)\"\n    }\n    return \"rgba(0, 0, 0, 0.9)\"\n  }, [theme])\n\n  useEffect(() => {\n    if (!canvasRef.current) {\n      return\n    }\n\n    const canvas = canvasRef.current\n    canvas.width = width\n    canvas.height = height\n\n    const canvasSize = Math.min(canvas.width, canvas.height)\n    const outerSquareSize = canvasSize * 0.5\n    const middleSquareSize = outerSquareSize * 0.45\n    const centerSquareSize = middleSquareSize * 0.16\n    const borderWidth = outerSquareSize * 0.15\n\n    const figure = new Figure({\n      squares: [\n        new Square({\n          size: outerSquareSize,\n          rotationOffset: 0,\n          rotation: 45,\n          color: \"rgba(0, 0, 0, 0)\",\n          borderColor: baseColor,\n          borderWidth: borderWidth,\n        }),\n        new Square({\n          size: middleSquareSize,\n          rotationOffset: 0,\n          rotation: 45,\n          color: \"rgba(0, 0, 0, 0)\",\n          borderColor: baseColor,\n          borderWidth: borderWidth,\n        }),\n        new Square({\n          size: centerSquareSize,\n          rotationOffset: 0,\n          rotation: 45,\n          color: baseColor,\n          borderColor: baseColor,\n          borderWidth: centerSquareSize * 0.2,\n        }),\n      ],\n    })\n\n    const orb = new OrbEngine(figure, canvas)\n    orbRef.current = orb\n\n    if (initialAnimation) {\n      if (initialAnimation === \"stopLoading\") {\n        orb.loading(false)\n      } else if (initialAnimation === \"idle\") {\n        orb.loading(false)\n        orb.reset()\n      } else {\n        const anyOrb = orb as unknown as Record<string, unknown>\n        const fn = anyOrb[initialAnimation] as unknown\n        if (typeof fn === \"function\") {\n          ;(fn as Function).call(orb)\n        }\n      }\n    }\n\n    return () => {\n      orbRef.current = null\n    }\n  }, [width, height, baseColor, initialAnimation])\n\n  useEffect(() => {\n    if (!orbRef.current) {\n      return\n    }\n    const orb = orbRef.current\n    const squares = orb.figure.squares\n    squares.forEach((square) => {\n      square.originalBorderColor = baseColor\n      square.borderColor = baseColor\n      if (square.originalColor !== \"rgba(0, 0, 0, 0)\") {\n        square.originalColor = baseColor\n        square.color = baseColor\n      }\n    })\n  }, [baseColor])\n\n  const renderShader = () => {\n    if (!props.shader) {\n      return null\n    }\n    if (props.shader.type === \"mesh-gradient\") {\n      const colors = Array.isArray(props.shader.colors) && props.shader.colors.length > 0 ? props.shader.colors : [\"#ffffff\", \"#a3a3a3\", \"#e5e5e5\"]\n      const distortion = typeof props.shader.distortion === \"number\" ? props.shader.distortion : 0.9\n      const swirl = typeof props.shader.swirl === \"number\" ? props.shader.swirl : 0.6\n      const speed = typeof props.shader.speed === \"number\" ? props.shader.speed : 0.2\n      return (\n        <div ref={shaderHostRef} className=\"w-full h-full\">\n          <MeshGradient\n            colors={colors as any}\n            distortion={distortion as any}\n            swirl={swirl as any}\n            speed={speed as any}\n            style={{ width: \"100%\", height: \"100%\" }}\n          />\n        </div>\n      )\n    }\n    if (props.shader.type === \"liquid-metal\") {\n      const colorTint = props.shader.colorTint || \"hsl(0, 0%, 100%)\"\n      const colorBack = props.shader.colorBack || colorTint\n      const repetition = typeof props.shader.repetition === \"number\" ? props.shader.repetition : 4\n      const softness = typeof props.shader.softness === \"number\" ? props.shader.softness : 0.3\n      const shiftRed = typeof props.shader.shiftRed === \"number\" ? props.shader.shiftRed : 0.3\n      const shiftBlue = typeof props.shader.shiftBlue === \"number\" ? props.shader.shiftBlue : 0.3\n      const distortion = typeof props.shader.distortion === \"number\" ? props.shader.distortion : 0.1\n      const contour = typeof props.shader.contour === \"number\" ? props.shader.contour : 1\n      const shape = props.shader.shape || \"none\"\n      const offsetX = typeof props.shader.offsetX === \"number\" ? props.shader.offsetX : 0\n      const offsetY = typeof props.shader.offsetY === \"number\" ? props.shader.offsetY : 0\n      const scale = typeof props.shader.scale === \"number\" ? props.shader.scale : 1\n      const rotation = typeof props.shader.rotation === \"number\" ? props.shader.rotation : 0\n      const speed = typeof props.shader.speed === \"number\" ? props.shader.speed : 1\n      return (\n        <div ref={shaderHostRef} className=\"w-full h-full\">\n          <LiquidMetal\n            style={{ width: \"100%\", height: \"100%\" }}\n            colorBack={colorBack as any}\n            colorTint={colorTint as any}\n            repetition={repetition as any}\n            softness={softness as any}\n            shiftRed={shiftRed as any}\n            shiftBlue={shiftBlue as any}\n            distortion={distortion as any}\n            contour={contour as any}\n            shape={shape as any}\n            offsetX={offsetX as any}\n            offsetY={offsetY as any}\n            scale={scale as any}\n            rotation={rotation as any}\n            speed={speed as any}\n          />\n        </div>\n      )\n    }\n    return null\n  }\n\n  useEffect(() => {\n    const link = () => {\n      const canvas = shaderHostRef.current ? (shaderHostRef.current.querySelector(\"canvas\") as HTMLCanvasElement | null) : null\n      if (!canvas) {\n        return false\n      }\n      shaderCanvasRef.current = canvas\n      if (orbRef.current) {\n        const mode = props.shader ? \"figure\" : \"none\"\n        orbRef.current.setShader(() => shaderCanvasRef.current, mode)\n      }\n      return true\n    }\n    if (props.shader) {\n      const ok = link()\n      if (!ok) {\n        const id = setTimeout(() => { link() }, 50)\n        return () => clearTimeout(id)\n      }\n    } else if (orbRef.current) {\n      orbRef.current.setShader(undefined, \"none\")\n    }\n  }, [props.shader?.type, props.shader?.colors, props.shader?.distortion, props.shader?.swirl, props.shader?.speed, props.shader?.colorBack, props.shader?.colorTint, props.shader?.repetition, props.shader?.softness, props.shader?.shiftRed, props.shader?.shiftBlue, props.shader?.contour, props.shader?.shape, props.shader?.offsetX, props.shader?.offsetY, props.shader?.scale, props.shader?.rotation])\n\n  return (\n    <div className={[\"relative\", props.className || \"\"].join(\" \")} style={{ width, height }}>\n      <canvas\n        ref={canvasRef}\n        width={width}\n        height={height}\n        aria-hidden={props.ariaHidden === true}\n        className=\"relative block\"\n      />\n      {props.shader && (\n        <div className=\"absolute inset-0 opacity-0 pointer-events-none\" aria-hidden>\n          {renderShader()}\n        </div>\n      )}\n    </div>\n  )\n}\n\n\n",
      "type": "registry:component",
      "target": "components/pulzar/orb.tsx"
    }
  ]
}