{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "pulzar/agents",
  "type": "registry:block",
  "title": "Pulzar Agents Docs",
  "description": "Guía genérica para crear módulos/agentes y relacionarlos con specs de dominio.",
  "files": [
    {
      "path": "registry/AGENTS.md",
      "content": "# AGENTS y Apps en Pulzar: arquitectura y guía para crear nuevos módulos\r\n\r\nEste documento explica la arquitectura de Pulzar y provee una guía paso a paso para crear nuevas apps/módulos de dominio (por ejemplo `@finance/` o `@integrations/`).\r\n\r\nImportante: la fuente de verdad sobre especificaciones es `lib/domain/specs-definition.md` y las `specs.md` dentro de cada dominio. Este documento es explicativo (cómo y por qué), no normativo. Ver sección “Fuente de verdad”.\r\n\r\n---\r\n\r\n## Fuente de verdad y relación con Specs\r\n\r\n- Máxima fuente de verdad: `lib/domain/specs-definition.md` (marco y plantilla obligatoria) y las `lib/domain/<contexto>/specs.md` de cada dominio.\r\n- Este `AGENTS.md` describe la arquitectura, los patrones y el “cómo implementarlo”.\r\n- Siempre mantener las specs de dominio alineadas con el estado real del código y datos.\r\n\r\nReferencias directas en el código:\r\n\r\n```1:20:lib/domain/specs-definition.md\r\n# Definición de Specs para Nuevas Funcionalidades\r\n\r\nEste documento describe cómo escribir un spec técnico funcional para implementar una nueva funcionalidad en el proyecto. Debe ser claro, accionable y verificable. Incluye una plantilla lista para copiar, una checklist de secciones obligatorias y ejemplos reales del repo.\r\n```\r\n\r\n---\r\n\r\n## Arquitectura general\r\n\r\n- UI (Next.js App Router): páginas y componentes bajo `app/` y `components/`.\r\n- API (Route Handlers): controladores delgados bajo `app/api/...` que delegan en servicios de dominio.\r\n- Dominio: lógica de negocio en `lib/domain/<contexto>/...` con `service.ts`, subservicios y `constant.ts`.\r\n- Datos: modelo y permisos en InstantDB (`instant.schema.ts` y `instant.perms.ts`).\r\n- Jobs/cron/eventos: funciones Inngest en `lib/domain/<contexto>/inngest.ts` (o en `lib/inngest.ts` cuando aplica).\r\n\r\nReferencias directas en el código:\r\n\r\n```1:20:instant.schema.ts\r\n// Docs: https://www.instantdb.com/docs/modeling-data\r\n\r\nimport { i } from \"@instantdb/core\";\r\n\r\nconst _schema = i.schema({\r\n  entities: {\r\n    organizations: i.entity({\r\n      clerkOrgId: i.string().indexed().unique(),\r\n```\r\n\r\n```64:99:instant.perms.ts\r\n// Ejemplo: entidades multi-tenant vinculadas a organización\r\n\"entitiesA\": {\r\n  \"allow\": {\r\n    \"view\": \"auth.id in data.ref('organization.members.id')\"\r\n  }\r\n},\r\n\"entitiesB\": {\r\n  \"allow\": {\r\n    \"view\": \"auth.id in data.ref('organization.members.id')\"\r\n  }\r\n},\r\n```\r\n\r\n```4:19:lib/domain/<contexto>/inngest.ts\r\n// Ejemplo: cron que encola eventos por organización\r\nexport const scheduleJob = inngest.createFunction(\r\n  { id: \"<contexto>/schedule\" },\r\n  { cron: \"0 * * * *\" },\r\n  async ({ step }) => {\r\n    try {\r\n      const result = await step.run(\"enqueueAll\", async () => {\r\n        return await MyContextService.enqueueForAllOrganizations()\r\n      })\r\n      return result\r\n```\r\n\r\n```1:21:app/api/<contexto>/action/route.ts\r\nimport { NextRequest, NextResponse } from \"next/server\"\r\nimport { auth } from \"@clerk/nextjs/server\"\r\nimport { MyContextService } from \"@/lib/domain/my-context/service\"\r\n\r\nexport async function POST(req: NextRequest) {\r\n    const a = await auth()\r\n    if (!a?.userId) {\r\n        return NextResponse.json({ ok: false, error: \"Unauthorized\" }, { status: 401 })\r\n    }\r\n    const orgId = a.orgId\r\n    if (!orgId) {\r\n        return NextResponse.json({ ok: false, error: \"Falta organización\" }, { status: 400 })\r\n    }\r\n    const res = await MyContextService.doAction({ orgClerkId: String(orgId) })\r\n```\r\n\r\n---\r\n\r\n## Estructura de carpetas\r\n\r\n- `app/`: UI y APIs por ruta.\r\n  - `app/api/<contexto>/.../route.ts`: controladores delgados que resuelven auth/tenancy con Clerk y delegan en servicios de dominio.\r\n  - `app/platform/<sección>/<contexto>/...`: páginas UI específicas de plataforma.\r\n- `components/`: componentes UI genéricos, reutilizables y autocontenidos.\r\n- `lib/domain/<contexto>/`: servicios de dominio, subservicios y constantes.\r\n  - `constant.ts`: URLs base, helpers de env.\r\n  - `service.ts`: API de dominio (no filtra detalles de infraestructura).\r\n  - `oauth/service.ts` u otros subservicios cuando aplica.\r\n  - `specs.md`: spec del dominio (obligatorio mantener actualizado).\r\n- `instant.schema.ts`: entidades y links.\r\n- `instant.perms.ts`: reglas de permisos por organización.\r\n\r\nEjemplo genérico de endpoints delgados:\r\n\r\n```197:205:lib/domain/specs-definition.md\r\n- Endpoints delgados:\r\n  - `app/api/<contexto>/action/route.ts` → `MyContextService.doAction`\r\n  - `app/api/<contexto>/query/route.ts` → `MyContextService.runQuery`\r\n```\r\n\r\n---\r\n\r\n## Patrón de controladores delgados (API)\r\n\r\nRegla: los `route.ts` validan autenticación y organización; delegan al servicio de dominio; no construyen requests complejos ni manejan persistencia.\r\n\r\nReferencia directa:\r\n\r\n```4:15:app/api/<contexto>/query/route.ts\r\nexport async function GET(req: NextRequest) {\r\n  const res = await MyContextService.runQuery({ q: new URL(req.url).searchParams.get(\"q\") })\r\n  if (!res.ok) {\r\n    return NextResponse.json(res, { status: 400 })\r\n  }\r\n  return NextResponse.json(res)\r\n}\r\n```\r\n\r\n---\r\n\r\n## Patrón de servicios de dominio\r\n\r\n- Servicio principal por contexto: `lib/domain/<contexto>/service.ts`.\r\n- Subservicios especializados: `lib/domain/<contexto>/<subdominio>/service.ts`.\r\n- Constantes y helpers: `lib/domain/<contexto>/constant.ts`.\r\n- Contratos retornan `ServiceResult<T>` y mensajes de error claros.\r\n\r\nReferencias directas:\r\n\r\n```22:41:lib/domain/my-context/service.ts\r\nexport class MyContextService {\r\n  static async enqueueForAllOrganizations(): Promise<ServiceResult<{ scheduled: number }>> {\r\n    try {\r\n      const listRes = await MyContextService.listOrganizations()\r\n      if (!listRes.ok) {\r\n        return { ok: false, error: listRes.error }\r\n      }\r\n      let scheduled = 0\r\n      for (const orgId of listRes.data.orgClerkIds) {\r\n        await inngest.send({ name: \"my-context/job.requested\", data: { orgClerkId: orgId } })\r\n        scheduled++\r\n      }\r\n      return { ok: true, data: { scheduled } }\r\n```\r\n\r\n```125:152:lib/domain/my-context/service.ts\r\nstatic async getSomethingForOrg(params: { clerkOrgId: string }): Promise<ServiceResult<{ value: string }>> {\r\n  try {\r\n    const { clerkOrgId } = params\r\n    const db = getAdminDb()\r\n    const qr: any = await db.query({\r\n      entitiesA: {\r\n        $: {\r\n          where: {\r\n            \"organization.clerkOrgId\": clerkOrgId,\r\n          },\r\n          limit: 1,\r\n          fields: [\"data\", \"createdAt\"],\r\n        },\r\n      },\r\n    })\r\n```\r\n\r\n---\r\n\r\n## Datos (InstantDB): entidades, links y permisos\r\n\r\nPasos para agregar datos de un nuevo módulo:\r\n1) Definir entidades y campos en `instant.schema.ts` con índices apropiados.\r\n2) Definir links obligatorios con `organizations` para scoping multi-tenant.\r\n3) Asegurar reglas en `instant.perms.ts` para `view` por organización; `secrets.view=false`.\r\n\r\nReferencias directas:\r\n\r\n```127:162:instant.schema.ts\r\n// Ejemplo de entidades genéricas A y B\r\nentitiesA: i.entity({\r\n  key: i.string().indexed().unique(),\r\n  name: i.string().indexed(),\r\n  status: i.string().indexed(),\r\n  createdAt: i.date().indexed(),\r\n  updatedAt: i.date().indexed().optional(),\r\n}),\r\nentitiesB: i.entity({\r\n  key: i.string().indexed().unique(),\r\n  kind: i.string().indexed(),\r\n  value: i.number().optional(),\r\n  createdAt: i.date(),\r\n  updatedAt: i.date().optional(),\r\n}),\r\n```\r\n\r\n```312:325:instant.schema.ts\r\n// Vínculos por organización y relación 1-1 A <> B\r\nentitiesAOrganization: {\r\n  forward: { on: \"entitiesA\", has: \"one\", label: \"organization\" },\r\n  reverse: { on: \"organizations\", has: \"many\", label: \"entitiesA\" },\r\n},\r\nentitiesBOrganization: {\r\n  forward: { on: \"entitiesB\", has: \"one\", label: \"organization\" },\r\n  reverse: { on: \"organizations\", has: \"many\", label: \"entitiesB\" },\r\n},\r\nentityARelatedB: {\r\n  forward: { on: \"entitiesA\", has: \"one\", label: \"entityB\" },\r\n  reverse: { on: \"entitiesB\", has: \"one\", label: \"entityA\" },\r\n},\r\n```\r\n\r\n---\r\n\r\n## UI y componentización\r\n\r\n- Regla: componentes autocontenidos; genéricos en `components/`, específicos de una ruta en `app/<ruta>/components/`; siempre en minúsculas.\r\n- Ejemplo de componentes de transacciones en plataforma:\r\n\r\n```1:12:app/platform/transactions/components/transactions-table.tsx\r\n\"use client\"\r\nimport { Badge } from \"@/components/ui/badge\"\r\nimport { ScrollArea } from \"@/components/ui/scroll-area\"\r\n// ...\r\n```\r\n\r\n---\r\n\r\n## Crear un nuevo módulo (genérico)\r\n\r\nChecklist de alto nivel:\r\n1) Escribir/actualizar el spec del dominio en `lib/domain/<contexto>/specs.md` siguiendo `lib/domain/specs-definition.md`.\r\n2) Modelar entidades y links en `instant.schema.ts` y permisos en `instant.perms.ts`.\r\n3) Implementar servicios en `lib/domain/<contexto>/service.ts` y subservicios.\r\n4) Crear controladores delgados en `app/api/<contexto>/.../route.ts`.\r\n5) Implementar UI componentizada en `app/<sección>/<contexto>/...` y/o `components/`.\r\n6) (Opcional) Jobs/eventos Inngest en `lib/domain/<contexto>/inngest.ts`.\r\n\r\nPlantillas (PowerShell):\r\n\r\n```powershell\r\n# Crear contexto base\r\nni lib/domain/my-context -ItemType Directory; ni lib/domain/my-context/constant.ts -ItemType File; ni lib/domain/my-context/service.ts -ItemType File;\r\nSet-Content lib/domain/my-context/constant.ts \"export const API_BASE=\\\"https://api.example.com\\\"`nexport function getEnvVar(name:string){const v=process.env[name] as string|undefined; if(!v){ throw new Error(name+\\\" no configurado\\\") } return v }`n\";\r\nSet-Content lib/domain/my-context/service.ts \"export type ServiceResult<T=any>={ok:true;data:T}|{ok:false;error:string}`nexport class MyContextService{}`n\";\r\n\r\n# Subservicio especializado (ej.: oauth)\r\nni lib/domain/my-context/oauth -ItemType Directory; ni lib/domain/my-context/oauth/service.ts -ItemType File;\r\nSet-Content lib/domain/my-context/oauth/service.ts \"export class OAuthService{}`n\";\r\n\r\n# Spec del dominio\r\nni lib/domain/my-context/specs.md -ItemType File; Set-Content lib/domain/my-context/specs.md \"# My Context`n`n(Completar siguiendo lib/domain/specs-definition.md)\\n\";\r\n```\r\n\r\n---\r\n\r\n## Seguridad y tenancy\r\n\r\n- Resolver usuario y organización en server con Clerk en cada controlador.\r\n- No exponer `secrets` al cliente; `secrets.view=false` en `instant.perms.ts`.\r\n- Variables de entorno se resuelven mediante helpers en `constant.ts`.\r\n\r\nReferencia directa:\r\n\r\n```90:106:instant.perms.ts\r\n// Secrets: no exponer vía cliente. Operaciones administrativas via admin token.\r\n\"secrets\": {\r\n  \"allow\": {\r\n    \"view\": \"false\"\r\n  }\r\n},\r\n```\r\n\r\n---\r\n\r\n## Observabilidad y tareas programadas\r\n\r\n- Usar Inngest para cron/eventos; envolver en try/catch y retornar `{ ok|error }`.\r\n\r\nReferencia directa:\r\n\r\n```21:35:lib/domain/finance/inngest.ts\r\nexport const syncMercadoPagoForOrg = inngest.createFunction(\r\n  { id: \"finance/mp.sync.org\" },\r\n  { event: \"finance/mp.sync.requested\" },\r\n  async ({ event, step }) => {\r\n    const orgClerkId = String((event.data as any)?.orgClerkId || \"\")\r\n    try {\r\n      const result = await step.run(\"syncOrg\", async () => {\r\n        return await FinanceService.handleSyncRequestedEvent({ orgClerkId })\r\n      })\r\n      return result\r\n```\r\n\r\n---\r\n\r\n## Ejemplo completo: Módulo genérico\r\n\r\n- Controladores delgados: `action`, `query`, `disconnect` (si aplica), `me` (si aplica).\r\n- Servicio principal: `lib/domain/my-context/service.ts`.\r\n- Subservicios: `lib/domain/my-context/<subdominio>/service.ts` (opcional).\r\n- Constantes/env: `lib/domain/my-context/constant.ts`.\r\n\r\nReferencias directas:\r\n\r\n```1:20:lib/domain/my-context/constant.ts\r\nexport const API_BASE = \"https://api.example.com\"\r\nexport function getEnvVar(name:string){const v=process.env[name] as string|undefined; if(!v){ throw new Error(name+\" no configurado\") } return v }\r\n```\r\n\r\n---\r\n\r\n## Integración ejemplo (GitHub opcional)\r\n\r\n- Controladores delgados:\r\n  - `app/api/integration/github/auth-url/route.ts` → `GitHubOAuthService.createAuthorizationUrl`\r\n  - `app/api/integration/github/callback/route.ts` → `GitHubOAuthService.handleCallback`\r\n  - `app/api/integration/github/disconnect/route.ts` → `GitHubOAuthService.disconnectForOrg`\r\n  - `app/api/integration/github/me/route.ts` → `GitHubIntegrationService.getViewer`\r\n  - `app/api/integration/github/orgs/route.ts` → `GitHubIntegrationService.listUserOrganizations`\r\n  - `app/api/integration/github/repos/route.ts` → `GitHubIntegrationService.listRepositories`\r\n  - `app/api/integration/github/access-token/route.ts` → server-to-server token\r\n\r\n- Servicio principal: `lib/domain/integrations/github/service.ts`.\r\n- Subservicio OAuth: `lib/domain/integrations/github/oauth/service.ts`.\r\n- Constantes/env: `lib/domain/integrations/github/constant.ts`.\r\n\r\nUI plataforma:\r\n\r\n```1:60:app/platform/organization/integrations/page.tsx\r\n// Tarjeta GitHub + componente de sesión CLI en ruta\r\n```\r\n\r\nDevOps:\r\n\r\n```1:120:../pulzar-devops/app/api/github/cli-run/route.ts\r\n// SSE que ejecuta: clone, checkout feature/<name>, git add/commit/push con progreso\r\n```\r\n\r\n---\r\n\r\n## Checklist de aceptación (DoD) para un nuevo módulo\r\n\r\n- Spec del dominio creado y actualizado (`lib/domain/<contexto>/specs.md`).\r\n- Entidades, links e índices definidos en `instant.schema.ts`.\r\n- Permisos por organización en `instant.perms.ts` (`view` mínimo; `secrets.view=false`).\r\n- Servicios y subservicios con `ServiceResult<T>` y errores claros.\r\n- Controladores delgados bajo `app/api/<contexto>/...` que delegan en servicios.\r\n- UI componentizada: genéricos en `components/`, específicos en `app/<ruta>/components/`.\r\n- Variables de entorno documentadas en la spec.\r\n- Logs/observabilidad y (si aplica) jobs/eventos Inngest.\r\n\r\n---\r\n\r\n## PowerShell (scaffolding rápido)\r\n\r\n```powershell\r\n# Crear spec base del contexto y archivos de servicio/constantes\r\nni lib/domain/new-feature -ItemType Directory; ni lib/domain/new-feature/constant.ts -ItemType File; ni lib/domain/new-feature/service.ts -ItemType File;\r\nSet-Content lib/domain/new-feature/constant.ts \"export const API_BASE=\\\"https://api.example.com\\\"`nexport function getEnvOrThrow(k:string){const v=process.env[k] as string|undefined; if(!v){ throw new Error(k+\\\" no configurado\\\") } return v }`n\";\r\nSet-Content lib/domain/new-feature/service.ts \"export type ServiceResult<T=any>={ok:true;data:T}|{ok:false;error:string}`nexport class NewFeatureService{}`n\";\r\nni lib/domain/new-feature/specs.md -ItemType File; Set-Content lib/domain/new-feature/specs.md \"# New Feature`n`n(Completar siguiendo lib/domain/specs-definition.md)\\n\";\r\n```\r\n\r\n---\r\n\r\n## Notas de estilo y convenciones\r\n\r\n- Java Style; evitar inline complejos; máxima legibilidad.\r\n- Componentes en minúsculas y autocontenidos.\r\n- Los “prompts” son funcionalidad: no editarlos salvo pedido explícito.\r\n\r\n\r\n",
      "type": "registry:item",
      "target": "AGENTS.md"
    },
    {
      "path": "registry/specs-definition.md",
      "content": "# Definición de Specs para Nuevas Funcionalidades\n\nNota canónica: Este archivo es la fuente de verdad sobre cómo definir specs. Las specs por dominio (`lib/domain/<contexto>/specs.md`) también son canónicas respecto a su ámbito. Para una guía arquitectónica y ejemplos de implementación, ver `AGENTS.md` en la raíz (explica patrones, estructura del proyecto y cómo crear nuevos módulos), pero la definición normativa vive aquí y en las specs de dominio.\n\nEste documento describe cómo escribir un spec técnico funcional para implementar una nueva funcionalidad en el proyecto. Debe ser claro, accionable y verificable. Incluye una plantilla lista para copiar, una checklist de secciones obligatorias y ejemplos reales del repo.\n\nReferencias útiles (según el tema de la funcionalidad):\n- Diseño de APIs REST: https://restfulapi.net/\n- GraphQL (si aplica): https://graphql.org/learn/\n- OAuth 2.0 (si aplica): RFC 6749\n- Accesibilidad (WCAG): https://www.w3.org/WAI/standards-guidelines/wcag/\n\n---\n\n## ¿Cuándo escribir un spec?\n\n- Antes de implementar cualquier funcionalidad no trivial que: cambie el modelo de datos, exponga nuevas APIs, requiera integraciones externas, o afecte la seguridad.\n- Si involucra múltiples capas (UI, API, dominio, datos), siempre.\n\n---\n\n## Estructura mínima obligatoria (Checklist)\n\n- Goal: objetivo concreto, medible.\n- Alcance y Fuera de alcance.\n- Historia(s) de usuario y UX/flujo.\n- Diseño de datos (InstantDB): entidades, links, permisos, migración.\n- API (Next.js Route Handlers): endpoints, métodos, contratos, errores.\n- Servicios de dominio: responsabilidad y API pública.\n- Integración con auth/tenancy: uso de Clerk y resolución de `orgId` en server.\n- Seguridad y cumplimiento: secrets, PII, permisos, mitigaciones.\n- Observabilidad: logs, métricas, eventos.\n- Testing: unitario, integración, e2e; datos de prueba.\n- Rollout/rollback: banderas, migraciones, compatibilidad.\n- Variables de entorno y configuración.\n- Performance y límites (timeouts, retries, paginado, batch size).\n- Accesibilidad e i18n (si aplica).\n- Aceptación (DoD): criterios verificables.\n\n---\n\n## Lineamientos por sección\n\n### Goal\n- Describe el “por qué” y el resultado esperado. Evitar vaguedades.\n\n### Alcance / Fuera de alcance\n- Enumera explícitamente lo que sí/no se hará en este ciclo.\n\n### UX / Flujos\n- Pantallas afectadas; navegación; estados vacíos; errores y loading.\n- Componentización obligatoria:\n  - Si es genérico → `components/`.\n  - Si es específico de una ruta → `app/<ruta>/components/`.\n  - Siempre en lower-case y autocontenidos (prop-driven, sin dependencias globales ocultas).\n\n### Datos (InstantDB)\n- Entidades nuevas o campos nuevos, con tipos.\n- Links entre entidades.\n- Permisos: reglas en `instant.perms.ts` (asegurar `view` mínimo necesario; `secrets.view=false`).\n- Migración: cómo poblar y versionar datos.\n\n### API (Route Handlers)\n- Rutas exactas bajo `app/api/...`.\n- Métodos, payloads, respuestas, códigos de error.\n- Autenticación y scoping por organización con Clerk en server (no pasar `orgId` desde cliente).\n- Controladores delgados: delegar toda la lógica de negocio/infra a servicios de `lib/domain/...`. Evitar construir cuerpos de requests a proveedores, lógica de autenticación, persistencia o parsing en el controlador.\n\n\n### Servicios de dominio (`lib/domain/...`)\n- API clara (métodos, tipos), sin filtrar detalles de infraestructura.\n- Manejo de errores y límites (timeouts, retries cuando corresponda).\n- Organización por responsabilidad:\n  - Servicio principal del contexto: `lib/domain/<contexto>/service.ts` (operaciones de negocio: persistencia de conexiones, fetchs al proveedor, etc.).\n  - Subservicios especializados: `lib/domain/<contexto>/<subdominio>/service.ts` (ej.: `oauth/service.ts` para autorización, intercambio de tokens y callback).\n  - Constantes y helpers de configuración: `lib/domain/<contexto>/constant.ts` (URLs base, helpers de env vars como `get...()` e `is...Enabled()`).\n- Los servicios deben exponer `ServiceResult<T>` y nunca arrojar detalles de infraestructura al controlador.\n\n\n### Seguridad\n- Secrets en `secrets` (InstantDB) y nunca visibles al cliente.\n- Validaciones de entrada; protección CSRF si aplica; SameSite de cookies; CORS.\n- Variables de entorno: no acceder directo desde controladores; resolver mediante helpers en `constant.ts` para validar presencia y dar errores claros.\n\n\n### Observabilidad\n- ¿Qué se loguea? ¿Dónde?\n- Métricas clave y eventos para auditoría.\n\n### Testing\n- Escenarios felices y errores.\n- Falsos (fixtures) de datos y mocks de integraciones externas.\n\n### Rollout / Rollback\n- Flags si fuera necesario.\n- Pasos para revertir cambios (migraciones incluidas).\n\n### Variables de entorno\n- Lista completa y formato esperado (ej.: URLs exactas registradas en proveedores externos).\n\n### Aceptación (Definition of Done)\n- Lista corta y verificable de criterios de aceptación.\n\n### Estilo / Código\n- Java Style; evitar inline complejos; legibilidad máxima.\n- “Prompts” son funcionalidad; no editarlos salvo pedido explícito.\n\n---\n\n## Estructura de carpetas (convención)\n\n- Dominio: `lib/domain/<contexto>/...`\n- Constantes por contexto: `lib/domain/<contexto>/constant.ts`\n- Subservicios por responsabilidad (si aplica): `lib/domain/<contexto>/<subdominio>/service.ts` (ej.: `oauth/service.ts`)\n- Datos: `instant.schema.ts`, `instant.perms.ts`\n- API: `app/api/<contexto>/.../route.ts`\n- UI: `app/<sección>/...` y `components/...`\n\n---\n\n## Plantilla (copiar y completar)\n\n```markdown\n# <NOMBRE DE LA FUNCIÓN / PROYECTO>\n\n## Goal\n- <Objetivo medible>\n\n## Alcance\n- <Incluye>\n\n## Fuera de alcance\n- <Excluye>\n\n## Historias de usuario / UX\n- <Escenarios y flujos, componentes y rutas afectadas>\n\n## Datos (InstantDB)\n- Entidades:\n  - <entity>: { campo: tipo, ... }\n- Links:\n  - <link>: forward/reverse\n- Permisos:\n  - <reglas>\n- Migración:\n  - <pasos>\n\n## API\n- Rutas:\n  - METHOD /app/api/.../route.ts\n- Contratos:\n  - Request/Response\n- Errores:\n  - Lista de códigos y formatos\n\n## Servicios de dominio\n- Archivo(s): `lib/domain/<contexto>/...`\n- Métodos públicos y responsabilidades\n\n## Seguridad\n- Secrets en `secrets` (view: false)\n- Validaciones y mitigaciones\n\n## Observabilidad\n- Logs, métricas, eventos\n\n## Testing\n- Unitario, integración, e2e\n- Fixtures/mocks\n\n## Rollout / Rollback\n- Plan de despliegue / reversión\n\n## Variables de entorno\n- <NOMBRE>=<formato>\n\n## Aceptación (DoD)\n- [ ] Criterio 1\n- [ ] Criterio 2\n```\n\n---\n\n## Patrones aplicables a OAuth 2.0 (si aplica)\n\n- Controladores delgados:\n  - `app/api/integration/<proveedor>/auth-url/route.ts` delega en `OAuthService.createAuthorizationUrl`\n  - `app/api/integration/<proveedor>/callback/route.ts` delega en `OAuthService.handleCallback`\n  - `app/api/integration/<proveedor>/disconnect/route.ts` delega en `<ContextService>.disconnectForOrg`\n- Servicios:\n  - Servicio principal: `lib/domain/<contexto>/service.ts` (upsert/disconnect/fetch/list)\n  - Subservicio OAuth: `lib/domain/<contexto>/oauth/service.ts` (autorización + callback)\n- Constantes y helpers: `lib/domain/<contexto>/constant.ts` (URLs base del proveedor, getters de env vars)\n\n---\n\n## Ejemplo real en este repo (para inspirar specs)\n\n- Integración OAuth 2.0 (Mercado Pago):\n  - Controladores delgados:\n    - `app/api/integration/mercadopago/auth-url/route.ts` → `MercadoPagoOAuthService.createAuthorizationUrl`\n    - `app/api/integration/mercadopago/callback/route.ts` → `MercadoPagoOAuthService.handleCallback`\n    - `app/api/integration/mercadopago/disconnect/route.ts` → `MercadoPagoIntegrationService.disconnectForOrg`\n  - Servicios:\n    - Servicio principal: `lib/domain/integrations/mercadopago/service.ts`\n    - Subservicio OAuth: `lib/domain/integrations/mercadopago/oauth/service.ts`\n  - Constantes y helpers: `lib/domain/integrations/mercadopago/constant.ts`\n  - Modelo: `externalConnections`, `secrets`, `oauthSessions`: `instant.schema.ts`\n  - Permisos: `instant.perms.ts`\n  - UI: `app/platform/organization/integrations/page.tsx`\n\n---\n\n## PowerShell (crear un nuevo spec)\n\n```powershell\nni lib/domain/my-feature-spec.md -ItemType File; Set-Content lib/domain/my-feature-spec.md \"# Mi Nueva Funcionalidad`n`n## Goal`n- ...`n\"\n```\n\n---\n\n## PowerShell (plantillas de organización de código por contexto)\n\n```powershell\n# Constantes del proveedor/ámbito\nni lib/domain/<contexto>/constant.ts -ItemType File; Set-Content lib/domain/<contexto>/constant.ts \"export const API_BASE=\\\"https://api.example.com\\\"`nexport function getClientId(){const v=process.env.CLIENT_ID as string|undefined; if(!v){ throw new Error(\\\"CLIENT_ID no configurado\\\") } return v }`n\"\n;\n# Servicio principal del contexto\nni lib/domain/<contexto>/service.ts -ItemType File; Set-Content lib/domain/<contexto>/service.ts \"export type ServiceResult<T=any>={ok:true;data:T}|{ok:false;error:string}`nexport class ContextService{}`n\"\n;\n# Subservicio especializado (ej.: oauth)\nni lib/domain/<contexto>/oauth -ItemType Directory; ni lib/domain/<contexto>/oauth/service.ts -ItemType File; Set-Content lib/domain/<contexto>/oauth/service.ts \"export class OAuthService{}`n\"\n```\n\n---\n\n## Checklist final de calidad del spec\n\n- [ ] Claridad: cualquiera del equipo puede ejecutarlo sin preguntas.\n- [ ] Completo: cubre datos, API, dominio, UI, seguridad, pruebas y despliegue.\n- [ ] Verificable: criterios de aceptación objetivos.\n- [ ] Cumple convenciones de carpeta, estilo y componentización.\n- [ ] Referencias a archivos reales cuando aplique.\n\n",
      "type": "registry:item",
      "target": "lib/domain/specs-definition.md"
    }
  ]
}